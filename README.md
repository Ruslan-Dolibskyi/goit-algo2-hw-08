# goit-algo2-hw-08

# Завдання 1. Реалізація Rate Limiter з використанням алгоритму Sliding Window для обмеження частоти повідомлень у чаті.

У чат-системі необхідно реалізувати механізм обмеження частоти повідомлень від користувачів для запобігання спаму. Реалізація повинна використовувати алгоритм Sliding Window для точного контролю часових інтервалів, який дозволяє відстежувати кількість повідомлень у заданому часовому вікні й обмежувати користувачів у надсиланні повідомлень, якщо ліміт перевищено.

## Технічні умови:

1. Реалізація повинна використовувати алгоритм Sliding Window для точного контролю часових інтервалів.

2. Базові параметри системи: розмір вікна (window_size) — 10 секунд і максимальна кількість повідомлень у вікні (max_requests) — 1.

3. Реалізуйте клас `SlidingWindowRateLimiter`.

4. Реалізуйте методи класу:
- `_cleanup_window` — для очищення застарілих запитів з вікна та оновлення активного часового вікна;
- `can_send_message` — для перевірки можливості відправлення повідомлення в поточному часовому вікні;
- `record_message` — для запису нового повідомлення й оновлення історії користувача;
- `time_until_next_allowed` — для розрахунку часу очікування до можливості відправлення наступного повідомлення.

5. Структура даних для зберігання історії повідомлень — `collections.deque`.

## Критерії прийняття:
1. При спробі відправити повідомлення раніше ніж через 10 секунд повертається методом `can_send_messag`e значення `False`.

2. При першому повідомленні від користувача завжди повертається `True`.

3. При видаленні всіх повідомлень з вікна користувача видаляється запис про користувача зі структури даних.

4. Метод `time_until_next_allowed` повертає час очікування в секундах.

5. Тестова функція згідно з прикладом прогнана й працює відповідно до очікувань.

## Шаблон завдання:

```
import random
from typing import Dict
import time
from collections import deque

class SlidingWindowRateLimiter:
    def __init__(self, window_size: int = 10, max_requests: int = 1):
				pass
    def _cleanup_window(self, user_id: str, current_time: float) -> None:
        pass

    def can_send_message(self, user_id: str) -> bool:
        pass

    def record_message(self, user_id: str) -> bool:
        pass

    def time_until_next_allowed(self, user_id: str) -> float:
        pass

# Демонстрація роботи
def test_rate_limiter():
    # Створюємо rate limiter: вікно 10 секунд, 1 повідомлення
    limiter = SlidingWindowRateLimiter(window_size=10, max_requests=1)

    # Симулюємо потік повідомлень від користувачів (послідовні ID від 1 до 20)
    print("\\n=== Симуляція потоку повідомлень ===")
    for message_id in range(1, 11):
        # Симулюємо різних користувачів (ID від 1 до 5)
        user_id = message_id % 5 + 1

        result = limiter.record_message(str(user_id))
        wait_time = limiter.time_until_next_allowed(str(user_id))

        print(f"Повідомлення {message_id:2d} | Користувач {user_id} | "
              f"{'✓' if result else f'× (очікування {wait_time:.1f}с)'}")

        # Невелика затримка між повідомленнями для реалістичності
        # Випадкова затримка від 0.1 до 1 секунди
        time.sleep(random.uniform(0.1, 1.0))

    # Чекаємо, поки вікно очиститься
    print("\\nОчікуємо 4 секунди...")
    time.sleep(4)

    print("\\n=== Нова серія повідомлень після очікування ===")
    for message_id in range(11, 21):
        user_id = message_id % 5 + 1
        result = limiter.record_message(str(user_id))
        wait_time = limiter.time_until_next_allowed(str(user_id))
        print(f"Повідомлення {message_id:2d} | Користувач {user_id} | "
              f"{'✓' if result else f'× (очікування {wait_time:.1f}с)'}")
        # Випадкова затримка від 0.1 до 1 секунди
        time.sleep(random.uniform(0.1, 1.0))

if __name__ == "__main__":
    test_rate_limiter()
```

## Очікуване виведення:

```
=== Симуляція потоку повідомлень ===
Повідомлення  1 | Користувач 2 | ✓
Повідомлення  2 | Користувач 3 | ✓
Повідомлення  3 | Користувач 4 | ✓
Повідомлення  4 | Користувач 5 | ✓
Повідомлення  5 | Користувач 1 | ✓
Повідомлення  6 | Користувач 2 | × (очікування 7.0с)
Повідомлення  7 | Користувач 3 | × (очікування 6.5с)
Повідомлення  8 | Користувач 4 | × (очікування 7.0с)
Повідомлення  9 | Користувач 5 | × (очікування 6.8с)
Повідомлення 10 | Користувач 1 | × (очікування 7.4с)

Очікуємо 4 секунди...

=== Нова серія повідомлень після очікування ===
Повідомлення 11 | Користувач 2 | × (очікування 1.0с)
Повідомлення 12 | Користувач 3 | × (очікування 0.7с)
Повідомлення 13 | Користувач 4 | × (очікування 0.4с)
Повідомлення 14 | Користувач 5 | × (очікування 0.0с)
Повідомлення 15 | Користувач 1 | ✓
Повідомлення 16 | Користувач 2 | ✓
Повідомлення 17 | Користувач 3 | ✓
Повідомлення 18 | Користувач 4 | ✓
Повідомлення 19 | Користувач 5 | ✓
Повідомлення 20 | Користувач 1 | × (очікування 7.0с)
```

# Завдання 2. Реалізація Rate Limiter з використанням алгоритму Throttling для обмеження частоти повідомлень у чаті.

У чат-системі необхідно реалізувати механізм обмеження частоти повідомлень від користувачів для запобігання спаму. Реалізація повинна використовувати алгоритм Throttling для контролю часових інтервалів між повідомленнями, який забезпечує фіксований інтервал очікування між повідомленнями користувача й обмежує частоту відправки, якщо цього інтервалу не дотримано.

## Технічні умови:

1. Реалізація повинна використовувати алгоритм Throttling для контролю часових інтервалів.

2. Базовий параметр системи: мінімальний інтервал між повідомленнями (min_interval) — 10 секунд.

3. Реалізуйте клас `ThrottlingRateLimiter`.

4. Реалізуйте методи класу:
- `can_send_message` — для перевірки можливості відправлення повідомлення на основі часу останнього повідомлення;
- `record_message` — для запису нового повідомлення з оновленням часу останнього повідомлення;
- `time_until_next_allowed` — для розрахунку часу до можливості відправлення наступного повідомлення.

5. Структура даних для зберігання часу останнього повідомлення — `Dict[str, float]`.

## Критерії прийняття:

1. При спробі відправити повідомлення раніше ніж через 10 секунд після попереднього повертається методом `can_send_message` значення `False`.

2. При першому повідомленні від користувача завжди повертається `True`.

3. Метод `time_until_next_allowed` повертає час очікування в секундах до наступного дозволеного повідомлення.

4. Тестова функція згідно з прикладом прогнана й працює відповідно до очікувань.

## Шаблон завдання:

```
import time
from typing import Dict
import random

class ThrottlingRateLimiter:
    def __init__(self, min_interval: float = 10.0):
        pass

    def can_send_message(self, user_id: str) -> bool:
        pass

    def record_message(self, user_id: str) -> bool:
        pass

    def time_until_next_allowed(self, user_id: str) -> float:
        pass

def test_throttling_limiter():
    limiter = ThrottlingRateLimiter(min_interval=10.0)

    print("\\n=== Симуляція потоку повідомлень (Throttling) ===")
    for message_id in range(1, 11):
        user_id = message_id % 5 + 1

        result = limiter.record_message(str(user_id))
        wait_time = limiter.time_until_next_allowed(str(user_id))

        print(f"Повідомлення {message_id:2d} | Користувач {user_id} | "
              f"{'✓' if result else f'× (очікування {wait_time:.1f}с)'}")

        # Випадкова затримка між повідомленнями
        time.sleep(random.uniform(0.1, 1.0))

    print("\\nОчікуємо 10 секунд...")
    time.sleep(10)

    print("\\n=== Нова серія повідомлень після очікування ===")
    for message_id in range(11, 21):
        user_id = message_id % 5 + 1
        result = limiter.record_message(str(user_id))
        wait_time = limiter.time_until_next_allowed(str(user_id))
        print(f"Повідомлення {message_id:2d} | Користувач {user_id} | "
              f"{'✓' if result else f'× (очікування {wait_time:.1f}с)'}")
        time.sleep(random.uniform(0.1, 1.0))

if __name__ == "__main__":
    test_throttling_limiter()
```

## Очікуване виведення:

```
=== Симуляція потоку повідомлень (Throttling) ===
Повідомлення  1 | Користувач 2 | ✓
Повідомлення  2 | Користувач 3 | ✓
Повідомлення  3 | Користувач 4 | ✓
Повідомлення  4 | Користувач 5 | ✓
Повідомлення  5 | Користувач 1 | ✓
Повідомлення  6 | Користувач 2 | × (очікування 7.4с)
Повідомлення  7 | Користувач 3 | × (очікування 7.6с)
Повідомлення  8 | Користувач 4 | × (очікування 7.6с)
Повідомлення  9 | Користувач 5 | × (очікування 7.6с)
Повідомлення 10 | Користувач 1 | × (очікування 7.4с)

Очікуємо 4 секунди...

=== Нова серія повідомлень після очікування ===
Повідомлення 11 | Користувач 2 | × (очікування 0.7с)
Повідомлення 12 | Користувач 3 | × (очікування 0.6с)
Повідомлення 13 | Користувач 4 | × (очікування 0.5с)
Повідомлення 14 | Користувач 5 | ✓
Повідомлення 15 | Користувач 1 | ✓
Повідомлення 16 | Користувач 2 | ✓
Повідомлення 17 | Користувач 3 | ✓
Повідомлення 18 | Користувач 4 | ✓
Повідомлення 19 | Користувач 5 | × (очікування 7.9с)
Повідомлення 20 | Користувач 1 | × (очікування 7.7с)
```